#!/bin/python3
# To execute the script call it with depth or breadth:
# eg. ./finder depth or ./finder breadth

import sys
import time
import argparse

from collections import deque


def getGrid():
    # Read file
    fileDescriptor = open('./blatt3_environment.txt', 'r')
    content = fileDescriptor.read()

    # Create grid
    grid = {}
    for x in range(0,10):
        grid[x] = {}

    # Get runner for grid population
    x = 0
    y = 0
    start = {}
    goal = {}

    # Parse string
    for char in content:
        if char is not '\n':
            grid[y][x] = char
            
            if char is 's':
                start = {'x': x, 'y': y}
            elif char is 'g':
                goal = {'x': x, 'y': y}
            x += 1
        else:
            x = 0
            y +=1
    return (grid, start, goal)

def getCoordinates(dictionary):
    return (dictionary['x'], dictionary['y'])

def search(args):
    collection = None
    if args['depth']:
        print("Depth")
        collection = []
    elif args['breadth']:
        print("Breadth")
        collection = deque()

    # Create grid for path
    path = {}
    for y in range(0,10):
        path[y] = {}
        for x in range(0, 20):
            path[y][x] = []

    # Get grid from txt
    grid, start, end = getGrid()

    # end coordinates
    endx, endy = getCoordinates(end)

    # Set initial path and coordinates for start
    current = start
    x, y = getCoordinates(start)
    path[y][x].append(start)
    running = True

    while (x is not endx or y is not endy) and running:
        # Getting charactors of adjacent tiles
        if args['watch']:
            time.sleep(0.05)
        right = grid[y][x+1]
        left  = grid[y][x-1]
        top = grid[y+1][x]
        bottom = grid[y-1][x]

        # Get path from current node
        lastPath = path[y][x]

        # Check for available neighbours and add them to the queue
        # Right
        if  right is not 'x' and (right is ' ' or right is 'g'):
            grid[y][x+1] = 'e'
            newPosition = {'x': x+1, 'y': y}
            if args['depth']:
                collection.insert(0, newPosition)
            else:
                collection.append(newPosition)
            new = list(lastPath)
            new.append(newPosition)
            path[y][x+1].extend(new)

        # Left
        if  left is not 'x' and (left is ' ' or left is 'g'):
            grid[y][x-1] = 'e'
            newPosition = {'x': x-1, 'y': y}
            if args['depth']:
                collection.insert(0, newPosition)
            else:
                collection.append(newPosition)
            new = list(lastPath)
            new.append(newPosition)
            path[y][x-1].extend(new)

        # Top
        if top is not 'x' and (top is ' ' or top is 'g'):
            grid[y+1][x] = 'e'
            newPosition = {'x': x, 'y': y+1}
            if args['depth']:
                collection.insert(0, newPosition)
            else:
                collection.append(newPosition)
            new = list(lastPath)
            new.append(newPosition)
            path[y+1][x].extend(new)

        # Bottom
        if bottom is not 'x' and (bottom is ' ' or bottom is 'g'):
            grid[y-1][x] = 'e'
            newPosition = {'x': x, 'y': y-1}
            if args['depth']:
                collection.insert(0, newPosition)
            else:
                collection.append(newPosition)
            new = list(lastPath)
            new.append(newPosition)
            path[y-1][x].extend(new)

        # Get coordinates from next element
        if len(collection) is not 0:
            if args['depth']:
                x, y = getCoordinates(collection.pop(0))
            else:
                x, y = getCoordinates(collection.popleft())
        else:
            # Can't find an path, exiting
            print('Empty Queue, no path found')
            running = False

        if args['watch']:
            drawGrid(grid)
            print('')

    print("Explored grid:\n")
    drawGrid(grid)
    print("\nFinal Path:\n")
    drawPath(path[endy][endx])

def depth(args):
    search({'depth': True, 'breadth': False, 'watch': args['watch']})
        
def breadth(args):
    search({'depth': False, 'breadth': True, 'watch': args['watch']})
          
def drawGrid(grid):
    string = ''
    for y in range(0,10):
        for x in range(0,20):
            string += grid[y][x]
        print(string)
        string = ''

def drawPath(path):
    grid, start, end = getGrid()
    for position in path:
        x, y = getCoordinates(position)
        if not (grid[y][x] == 'g' or grid[y][x] == 's'):
            grid[y][x] = 'p'
    drawGrid(grid)

parser = argparse.ArgumentParser(description='Argparse for depth-/breadth Search')

subparser = parser.add_subparsers(title='Subcommands', description='Various subcommands')

depthSearch = subparser.add_parser('depth', help='Executes depth search')
depthSearch.add_argument('--watch', action='store_true', help='Watch the algorithm searching')
depthSearch.set_defaults(func=depth)

breadthSearch = subparser.add_parser('breadth', help='Executes breadth search')
breadthSearch.add_argument('--watch', action='store_true', help='Watch the algorithm searching')
breadthSearch.set_defaults(func=breadth)

args = parser.parse_args()

if hasattr(args, 'func'):
    args.func(vars(args))
