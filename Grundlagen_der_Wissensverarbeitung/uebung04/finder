#!/usr/bin/env python3
# To execute the script call it with depth or breadth:
# eg. ./finder depth or ./finder breadth

import sys
import time
import math
import argparse

from collections import deque

FLAG_DEBUG = True
# Global variable with portals. We need to know them for distance check.
portals = {}

def getGrid(args, first):
    # Read file
    fileDescriptor = None
    if 'blatt4a' in args and args['blatt4a']:
        fileDescriptor = open('./blatt4_environment_a.txt', 'r')
    elif 'blatt4b' in args and args['blatt4b']:
        fileDescriptor = open('./blatt4_environment_b.txt', 'r')
    else:
        fileDescriptor = open('./blatt3_environment.txt', 'r')
    content = fileDescriptor.read()

    # Create grid
    grid = {}
    for y in range(0,10):
        grid[y] = {}

    # Get runner for grid population
    x = 0
    y = 0
    start = {}
    goal = {}

    # Parse string
    for char in content:
        if char is not '\n':
            grid[y][x] = Node(x, y, char)

            if char is 's':
                start = grid[y][x]
            elif char is 'g':
                goal = grid[y][x]
            elif char is not ' ' and char is not 'x' and first:
                if char not in portals:
                    portals[char] = []
                portals[char].append(grid[y][x])
            x += 1
        else:
            x = 0
            y += 1
    print(portals)

    # Create a grid of nodes.
    # Adjacent nodes can be found under grid[y][x].children
    for y in range(0,10):
        for x in range(0,20):
            if x+1 in grid[y]:
                grid[y][x].children.append(grid[y][x+1])
            if x-1 in grid[y]:
                grid[y][x].children.append(grid[y][x-1])
            if y-1 in grid:
                grid[y][x].children.append(grid[y-1][x])
            if y+1 in grid:
                grid[y][x].children.append(grid[y+1][x])

    for char, portal in portals.items():
        portal[0].children.append(portal[1])
        portal[1].children.append(portal[0])

    return (grid, start, goal)

def heuristic(node, end):
    return node.getDistance(end)

# compares f (distance to goal and cost) of two elements (node and child) in l
def comparef(element, ch, l):
    for element in l:
        if element.getCoordinates == ch.getCoordinates and element.priority <= ch.priority:
            return True


def search(args):

    # intialize open and closed list
    openlist = Heap("priority")
    closedlist = []
    cost_accu = 0
    # get grid from txt
    grid, start, end = getGrid(args, True)
    if FLAG_DEBUG:
        print("Start: {0}, End: {1}".format(start.getCoordinates(), end.getCoordinates()))
    # set initial path and coordinates for start
    openlist.push(start)
    running = True
    expansionCounter = 0

    while openlist.getSize() != 0 and running:
        if args['watch']:
            time.sleep(0.05)
            drawPath(closedlist, args)
        current = openlist.pop()
        if current.character == 'x':
            pass
        else:
            for child in current.children:
                if child == end:
                    closedlist.append(current)
                    closedlist.append(child)
                    drawPath(closedlist, args)
                    running = False
                child.priority = heuristic(current, end) + (child.priority + cost_accu)
                cost_accu += 1
                if comparef(current, child, openlist.storage) or comparef(current, child, closedlist):
                    continue
                else:
                    openlist.push(child)
                    expansionCounter += 1
            closedlist.append(current)

    print("Open Nodes {}".format(len(openlist.storage)))
    print("Closed Nodes {}".format(len(closedlist)))
    print("Opened Nodes {}".format(expansionCounter))


def drawGrid(grid):
    string = ''
    for y in range(0,10):
        for x in range(0,20):
            string += grid[y][x].character
        print(string)
        string = ''

def drawPath(path, args):
    grid, start, end = getGrid(args, False)
    for position in path:
        x, y = position.getCoordinates()
        if not (grid[y][x].character == 'g' or grid[y][x].character == 's'):
            grid[y][x].character = 'e'
    drawGrid(grid)

class Coordinate:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    def getCoordinates(self):
        return (self.x, self.y)

def getNode(grid, x, y):
    return grid[x][y]

class Node:
    def __init__(self, x, y, character):
        self.children = []
        self.distance = 0
        self.priority = 0
        self.character = character
        self.x = x
        self.y = y
    def getCoordinates(self):
        return (self.x, self.y)
    def getDistance(self, node):
        distances = []
        # Get normal distance
        xdif = math.fabs(self.x - node.x)
        ydif = math.fabs(self.y - node.y)
        # Push distance to distance array
        distances.append(xdif+ydif)
        for key, portal in portals.items():
            # One direction
            # To Portal
            xToPortal = math.fabs(self.x - portal[0].x)
            yToPortal = math.fabs(self.y - portal[0].y)

            # From Portal to goal
            xFromPortal = math.fabs(self.x - portal[1].x)
            yFromPortal = math.fabs(self.y - portal[1].y)

            # Add distances + 1 for travel through portal
            distances.append(xToPortal+yToPortal + xFromPortal + yFromPortal + 1)

            # The other direction
            # To Portal
            xToPortal = math.fabs(self.x - portal[1].x)
            yToPortal = math.fabs(self.y - portal[1].y)

            # From Portal to goal
            xFromPortal = math.fabs(self.x - portal[0].x)
            yFromPortal = math.fabs(self.y - portal[0].y)

            # Add distances + 1 for travel through portal
            distances.append(xToPortal+yToPortal + xFromPortal + yFromPortal + 1)

        return min(distances)

class Heap():
    def __init__(self, key_string):
        self.storage = []
        self.key = key_string

    def sortFunc(self, elem):
        return eval("elem." + self.key)

    def getSize(self):
        return len(self.storage)

    def pop(self):
        return self.storage.pop(0)

    def push(self, element):
        self.storage.insert(0, element)
        self.storage.sort(key=self.sortFunc)

    def add(self, element):
        self.storage.append(element)
        self.storage.sort(key=self.sortFunc)

    def get(self, index):
        return self.storage[index]


parser = argparse.ArgumentParser(description='Argparse for depth-/breadth Search')

subparser = parser.add_subparsers(title='Subcommands', description='Various subcommands')

astarSearch = subparser.add_parser('astar', help='Executes breadth search')
astarSearch.add_argument('--watch', action='store_true', help='Watch the algorithm searching')
astarSearch.add_argument('--blatt4a', action='store_true', help='Use 4b')
astarSearch.add_argument('--blatt4b', action='store_true', help='Use 4a')
astarSearch.set_defaults(func=search)

args = parser.parse_args()

if hasattr(args, 'func'):
    args.func(vars(args))
