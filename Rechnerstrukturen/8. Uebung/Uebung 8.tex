\documentclass{article}
\usepackage[a4paper]{geometry}
\usepackage{amsfonts}
\usepackage{alltt}
\usepackage{amsmath,amssymb}        % Mathpack für Formeln jeder Art
\usepackage[parfill]{parskip}       % Autoamtisch Newline, wenn Zeilenumbruch im Quelltext.
\usepackage[utf8]{inputenc}         % UTF8 Zeichensatz. 
\usepackage{xstring}				% Gebraucht für Circuitikz
\usepackage{tikz}                   % Wichtig für Zeichnungen aller Art
\input{kvmacros}                    % Kv Diagramme
\usepackage[siunitx]{circuitikz}    % Diagramme und Schaltungen
\usepackage{pgffor}
\usepackage{fancyhdr}
\usepackage{array}

\title{RS - Übung 8}
\author{Arne Beer (MN 6489196), \\
Rafael Epplee (MN 6269560), \\
Julian Polatynski (MN 6424884)}

\begin{document}
\maketitle

\section*{8.1}

Das Schaltdiagramm wurde von uns mit Hades gezeichnet und befindet sich im Anhang, da wir nicht wussten wie man es sinnvoll und ohne es zu kürzen in Latex einfügen sollte. In dem Schaltbild befinden sich normale Negationen die wir aus Platzgründen nicht als 2:1 Multiplexer dargestellt haben. Oben rechts ist jedoch ein exemplarischer Inverter aufgezeigt. 

\section*{8.2}

\subsection*{a)} 
    \kvnoindex
     \begin{tabular}{c c c c|c }
    $ x_3$ & $x_2$ & $x_1$ & $x_0$ & $f(x_0, x_1, x_2, x_3)$ \\ \hline
    0&0&0&0&1\\
    0&0&0&1&1\\
    0&0&1&0&1\\
    0&0&1&1&1\\
    0&1&0&0&1\\
    0&1&0&1&0\\
    0&1&1&0&0\\
    0&1&1&1&0\\
    1&0&0&0&1\\
    1&0&0&1&1\\
    1&0&1&0&1\\
    1&0&1&1&1\\
    1&1&0&0&1\\
    1&1&0&1&1\\
    1&1&1&0&1\\
    1&1&1&1&1\\

    \end{tabular}

\karnaughmap{4}{f($x_0$,$x_1$,$x_2$,$x_3$):}{{$x_3$}{$x_1$}{$x_2$}{$x_0$}}%
    {1110110011111111}
    {
    \put(2,1){\oval(3.9,1.9)[]}
    \put(0.5,2){\oval(0.9,3.9)[]}
    \put(0.5,2){\oval(0.9,3.9)[]}
    \put(2,0){\oval(3.9,1.9)[t]}
    \put(2,4){\oval(3.9,1.9)[b]}
    }

\subsection*{b)}

DNF=$x_3\vee \overline{x_2}\vee (\overline{x_1} \wedge \overline{x_0})$ \\
KNF=$(\overline{x_0}\vee x_3 \vee \overline{x_2})\wedge (\overline{x_1}\vee x_3 \vee \overline{x_2}) $\\


    DNF: \\

    \begin{circuitikz} \draw
      (0,2) node[and port] (myand) {}
      (2,1) node[and port] (myand2) {}
      (myand.in 1) node[anchor=east] {$x_3$}
      (myand.in 2) node[anchor=east] {$\overline{x_2}$}
      (myand.out) -| (myand2.in 1)

      (0,0) node[or port] (myor) {}
      (myor.in 1) node[anchor=east] {$\overline{x_1}$}
      (myor.in 2) node[anchor=east] {$\overline{x_2}$}
      (myor.out) -| (myand2.in 2) {}

    ;\end{circuitikz}
\\

KNF: \\

    \begin{circuitikz} \draw
      (0,4.5) node[or port] (myor) {}
      (2,3.5) node[or port] (myor2) {}
      (myor.in 1) node[anchor=east] {$x_3$}
      (myor.in 2) node[anchor=east] {$\overline{x_0}$}
      
      (myor2.in 2) node[anchor=east] {$\overline{x_2}$}
      (myor.out) -| (myor2.in 1)

      (0,1) node[or port] (myor3) {}
      (2,2) node[or port] (myor4) {}
      (myor3.in 1) node[anchor=east] {$x_3$}
      (myor3.in 2) node[anchor=east] {$\overline{x_1}$}
      
      (myor4.in 1) node[anchor=east] {$\overline{x_2}$}
      (myor3.out) -| (myor4.in 2)

      (4,2.75) node[and port] (myand) {}
      (myor2.out) -| (myand.in 1)
      (myor4.out) -| (myand.in 2)

    ;\end{circuitikz}




\section*{8.3}
a)
Die leeren Felder bedeuten, dass das hier ein undefinierter Wert vorliegt.\\
\begin{circuitikz} \draw
        (1,0.4) -- (9,0.4) {}
        (1,0.4) -- (1,8.6) {}

        (2,-0.5) node[] {1}
        (3,-0.5) node[] {2}
        (4,-0.5) node[] {3}
        (5,-0.5) node[] {4}
        (6,-0.5) node[] {5}
        (7,-0.5) node[] {6}
        (8,-0.5) node[] {7}
        (9,-0.5) node[] {8}

        (0,8) node[] {a}
        (0,7) node[] {b}
        (0,6) node[] {$\overline{a}$}
        (0,5) node[] {$\overline{b}$}
        (0,4) node[] {$(b\wedge \overline{a})$}
        (0,3) node[] {($a\wedge \overline{b})$}
        (0,2) node[] {x}
        (0,1) node[] {y}

        (1,7.6) -- (2,7.6) -- (2,8.4) -- (9,8.4) {}       % Zeichnen des Impulsdiagrams für a

        (1,6.6) -- (2,6.6) -- (2,7.4) -- (9,7.4) {}       % Zeichnen des Impulsdiagrams für b

        (2,6.4) -- (3,6.4) -- (3,5.6) -- (9,5.6) {}       % Zeichnen des Impulsdiagrams für \overline a

        (2,5.4) -- (3,5.4) -- (3,4.6) -- (9,4.6) {}       % Zeichnen des Impulsdiagrams für \overline b

        (3,4.4) -- (4,4.4) -- (4,3.6) -- (9,3.6) {}% Zeichnen für b und nicht a

        (3,3.4) -- (4,3.4) -- (4,2.6) -- (9,2.6) {}% Zeichnen für a und nicht b

        (4,2.4) -- (5,2.4) -- (5,1.6) -- (9,1.6) {} % Zeichnen für X

        (5,0.6) -- (9,0.6) {}% Zeichnen für y

    ;\end{circuitikz}\\
b)\\
\begin{circuitikz} \draw

        (1,0.4) -- (9,0.4) {}
        (1,0.4) -- (1,8.6) {}

        (2,-0.5) node[] {1}
        (3,-0.5) node[] {2}
        (4,-0.5) node[] {3}
        (5,-0.5) node[] {4}
        (6,-0.5) node[] {5}
        (7,-0.5) node[] {6}
        (8,-0.5) node[] {7}
        (9,-0.5) node[] {8}

        (0,8) node[] {a}
        (0,7) node[] {b}
        (0,6) node[] {$\overline{a}$}
        (0,5) node[] {$\overline{b}$}
        (0,4) node[] {$(b\wedge \overline{a})$}
        (0,3) node[] {($a\wedge \overline{b})$}
        (0,2) node[] {x}
        (0,1) node[] {y}

        (1,8.4) -- (2,8.4) -- (2,7.6) -- (9,7.6) {}       % Zeichnen des Impulsdiagrams für a

        (1,6.6) -- (2,6.6) -- (2,7.4) -- (9,7.4) {}       % Zeichnen des Impulsdiagrams für b

        (2,5.6) -- (3,5.6) -- (3,6.4) -- (9,6.4) {}       % Zeichnen für \overline a

        (2,5.4) -- (3,5.4) -- (3,4.6) -- (9,4.6) {}       % Zeichnen für \overline b

        (3,3.6) -- (4,3.6) -- (4,4.4) -- (9,4.4) {}       % Zeichnen fpr b nicht a

        (3,2.6) -- (9,2.6) {}       % Zeichnen für a nicht b

        (4,1.6) -- (5,1.6) -- (5,2.4) --(9,2.4) {} %Zeichnen für x

        (5,0.6) -- (9,0.6) {} %Zeichnen für y

    ;\end{circuitikz}


\section*{8.4}
    

    \subsection*{a)}

      Zunächst berechnen die SUM-Blöcke die Generate- und Propagate-Werte für jede Stelle (parallel).

      Jeder CLA-Block berechnet aus je zwei Propagate- und Generate-Werten für zwei Stellen einen neue Propagate- und Generate-Werte, die für beide Stellen zusammenfassend gelten. Der nächste CLA-Block fasst die Ergebnisse seiner beiden Vorgänger zusammen, also für insgesamt 4 Stellen. So geht es weiter, bis ein CLA-Block die Werte (und damit einen Carry-Wert) für alle n Stellen berechnet hat. Dieser Block steht in dem Baum aller CLA-Blöcke auf Stufe $log_2(n)$.

      Dann werden die berechneten Carry-Werte noch zurückgereicht, was über 4 Stufen 4 Zeiteinheiten kostet.

      Letztendlich brauchen wir also eine Zeiteinheit für die Berechnung der ersten Generate- und Propagate-Werte, $log_2(n)$ Zeiteinheiten, um alle Carry-Werte zu berechnen, und $log_2(n)$ Zeitheinheiten um die berechneten Carry-Werte wieder über den CLA-Baum zurückzureichen. Verzögerung insgesamt: $2 \cdot log_2(n) + 1$



    \subsection*{b)}
      
      Bei einem Carry-Select Addierer werden bei n-bit Additionen mehrere Ripple-Carry Addierer der Länge $\frac{n}{m}$  hintereinandergeschaltet $(m_0, m_1,\cdots,m_n)$. Je Gruppe berrechnen zwei Ripple-Carry Stränge parallel die Binärzahlen und Carrys für ihren Bereich mit einem Carry-in von  0 beim einen Strang und 1 beim anderen. \\
      Die Zeitschritte einer solchen Addition lassen sich folgendermaßen berrechnen:
      $f(m)=\frac{n}{m}+m-1$ \\
      "Anzahl Multiplexer" +"Anzahl der Volladierer in m" -  "1 Multiplexer der in $\frac{n}{m}$ mitgezählt wird". \\
      Wenn man diese Funktion ableitet, erhält man $f'(m)=1-\frac{n}{m^2}$. Daraus lässt sich das Minimum von m errechnen, welches bei $m=\sqrt{n}$ liegt.
      Mit diesem m ist die Verzögerung minimal. 

    \subsection*{c)}

      Nach der oben genannten  Formel sich die Zeitverzögerung für eine Carry-Lookahead Addition nach der Formel $2 \cdot log_2(n) + 1$. Somit erhalten wir für einen 64-bit Addierer eine Zeitverzögerung von 13 Einheiten. Das sind umgerechnet 455 ps. 
      Es ergibt sich eine Taktrate von ca. 2,198 Ghz

      Wir erhalten für einen 256-bit Addierer eine Zeitverzögerung von 17  Einheiten. Das sind umgerechnet 595 ps. 
      Es ergibt sich eine Taktrate von ca. 1,681 Ghz


      Für eine Carry-Select Addition mit n=64 ist die optimale Aufteilung in Ripple-Carrys folgende mit der oben gewählten Formel zuberrechnen. \\
      $m=\sqrt{64}=8$ \\
      $f(8)=\frac{64}{m}+m-1=15$\\
      Es ergeben sich 15 Zeiteinheiten mit n=64 bit. Das ist eine Verögerung von 525 ps.
      Es ergibt sich eine Taktraten von ca. 1,904 Ghz

      Für eine Carry-Select Addition mit n=256 ist die optimale Aufteilung in Ripple-Carrys folgende mit der oben gewählten Formel zuberrechnen. \\
      $m=\sqrt{256}=16$ \\
      $f(16)=\frac{256}{m}+m-1=131$\\
      Es ergeben sich 31 Zeiteinheiten mit n=64 bit. Das ist eine Verögerung von 1,085 ns.
      Es ergibt sich eine Taktrate von ca. 921,7 MHz

      Für eine Ripple-Carry Addition ergeben sich bei n-bit n Zeiteinheiten. Somit sind es bei bei 64-bit Additionen 64 Zeiteinheiten, was eine Verzögerung von 2,24 ns ausmacht.
      Es ergibt sich eine Taktrate von ca. 446,4 MHz

      Für eine Ripple-Carry Addition ergeben sich bei n-bit n Zeiteinheiten. Somit sind es bei bei 256-bit Additionen 256 Zeiteinheiten, was eine Verzögerung von 8,96 ns ausmacht.
      Es ergibt sich eine Taktrate von ca. 111,6 MHz

\end{document}